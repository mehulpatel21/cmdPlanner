#!/bin/bash

# Basic scheduling program
working_dir=~/coursenotes
mkdir -p $working_dir/config
config_file="$working_dir/config/cnotes.conf"
if [ ! -f $config_file ]; then
  echo Error: Could not initialize: $working_dir/config/cnotes.conf not found.
  # new config
  echo -ne "Create one now (y/n)? "
  read input
  cc=
  cf=
  while [ "$input" == "y" ] || [ "$input" == "Y" ]; do
    echo -ne "Enter course(s), separating multiple aliases with pipes"\
    " (eg course1|courseOne)\n> "
    read input
    cc=$cc" $input"
    echo -ne "Enter filename (eg courseFile1)\n> "
    read input
    cf=$cf" $input"
    echo -ne "Add another course (y/n)?\n> "
    read input
  done
  if [ "$cc" == "" ] || [ "$cf" == "" ]; then
    echo "Could not initialize config"
    exit 2
  else
    echo "courses=\"${cc/ /}\"" >$working_dir/config/cnotes.conf
    echo "files=\"${cf/ /}\"" >>$working_dir/config/cnotes.conf
    echo -ne "Done.\n$(cat $working_dir/config/cnotes.conf)\n"
    exit 1
  fi
fi
source $working_dir/config/cnotes.conf
mkdir -p $working_dir/deleted
cd $working_dir

# Parameter pulling
operation="$1"
course="$2"
args="$3"
shift 
shift
message="$*"
shift
addargs="$*"

# Course selection for in/output file
touch $files
conf_courses=" $courses "
conf_search="\<$course\>"

if [ "$course" == "" ]; then
  file=
else
  pos=$(($(echo $conf_courses |sed "s/[^ ]*$conf_search.*//g" |wc -w) + 1))
  file=$(echo $files |cut -d' ' -f$pos)
fi

usage="\
Usage: $(basename $0) -acCDfhpPrzRu [-o [-c/N]] [COURSE] [ARGS] [ADDARGS]
 -a, --add COURSE ARGS
      append ADDARGS to first line containing ARGS in COURSE
 -c, --clear COURSE ARGS
      delete first line containing ARGS from COURSE, temporarily
      storing it in working_dir/deleted/lastline
 -D, --del COURSE
      delete COURSE file, temporarily storing it in working_dir/deleted/
 -f, --find ARGS
      print file lines containing ARGS
 -h, --help
      show this menu
 -l, --list
      print all files
 -p, --push COURSE ARGS
      append ARGS to COURSE
 -P, --pull COURSE
      read from COURSE or print all with no COURSE
 -r, --rep COURSE ARGS ADDARGS
      replace first occurence of ARGS with ADDARGS
 -z, --repl COURSE ARGS ADDARGS
      same as -r, but relplaces the whole line
 -R, --rest COURSE 
      swap deleted COURSE file with one in working_dir/deleted
 -o, --sort [-c]
      print tasks in chronological order if the have monthDay appended to
      them (eg nov15 or sep17). With -c supllied, prints this and next month
      calendars, highlighting tasks
 -u, --undo COURSE
      append most recently cleared line to COURSE
 -C, --conf
      print config settings
"

# Operation selection
case "$operation" in
  "--push" | "-p")
  #  Push - Sends input to text file
  #  Requires input ($message), file ($course => $file) 
    if [ "$file" != "" ] && [ "$message" != "" ] && [ "$course" != "" ]; then
      echo "$message" >> $file
      echo Added \'$message\' to $file
      bash $0 --pull $course
    else
      echo Invalid format
      bash $0
    fi
    ;;

  "--pull" | "-P")
  #  Pull - Prints contents of a file or of all files (with no params)
  #  Requires (optional) file to read from ($course => $file)
    if [ "$file" == "" ]; then
      bash $0 list
    else
      if [ -f $working_dir/$file ]; then
        echo \> $(basename $file)
        cat $file
      else
        echo File \'$file\' not found
      fi
    fi
    ;;

  "-D" | "--del")
  #  Delete - Removes entire contents of input file and replaces with empty one.
  #+ Stores file in deleted/ until next deletion operation.
  #  Requires input file ($course => $file)
    if [ "$file" != "" ]; then
      echo -n "Really delete $file? [Y/n]: "
      read confirm
      if [ "$confirm" == "y" ] || [ "$confirm" == "Y" ]; then
        mv $file deleted/
        touch $file
        echo Sent $file\
        to $working_dir/deleted/$file
        bash $0 --list
      fi
    else
      echo Invalid format
      bash $0
    fi
    ;;

  "--clear" | "-c")
  #  Clear - Removes a single line from file, determined by the first string
  #+ containing input substring
  #  Requires input file ($course => $file) and substring ($message)
    if [ "$message" != "" ] && [ "$file" != "" ]; then
      line=$(grep -m1 "$message" $file) &&
      echo $line >$working_dir/deleted/lastline &&
      sed -i /"$line"/d $file &&
      echo Deleted \'$line\' from $file &&
      bash $0 --pull $course ||
      echo String \'$message\' not found
    else
      echo Invalid format
      bash $0
    fi
    ;;

  "--add" | "-a")
  #  Append - Appends a string onto existing line in text file
  #  Requires input file ($course => $file), substring to search for ($args),
  #+ string to append ($addargs)"
    if [ "$args" != "" ] && [ "$file" != "" ] && [ "$addargs" != "" ]; then
      line=$(grep -m 1 $args $file)
      if ! [ -z $line ]; then
        sed -i s/"$line"/"$line$addargs"/g $file
        echo Appended \'"$addargs"\' to $file: $line
        bash $0 --pull $course
      else
        echo Could not find \'$args\'
      fi
    else
      echo Invalid format
      bash $0
    fi
    ;;

  "--list" | "-l")
  # List - Prints contents of text files in working directory
    for i in $files; do
      echo '> '$i
      cat $i
    done
    ;;
  "--undo" | "-u")
  #  Undo - restores last deleted line to a file
  #  Requires input file ($course ==> $file) 
    if [ "$file" != "" ]; then
      if $(grep -q . $working_dir/deleted/lastline); then
        cat $working_dir/deleted/lastline >> $file
        echo Appended \'$(cat $working_dir/deleted/lastline)\'\
        to $file
        bash $0 --pull $course
      else
        echo Last line does not exist
      fi
    else
      bash $0
    fi
    ;;

  "--rest" | "-R")
  # Restore - Replaces text file in deleted/, swapping it with existing one in working directory
  # Requires input file ($course => $file)
    if [ "$file" != "" ]; then
      if [ -f $working_dir/deleted/$file ]; then
        mv $working_dir/deleted/$file $working_dir/tmp
        if [ -f $working_dir/$file ]; then
          mv $working_dir/$file $working_dir/deleted/
        fi
        mv $working_dir/tmp $working_dir/$file
        echo Restored $file
        bash $0 --pull $course
      else
        echo Could not restore $file: does not exist
      fi
    else
      bash $0
    fi
    ;;

  "--rep" | "-r" | "-z" | "--repl")
  #  Replace - Replaces a single word or line in input file with another one
  #  Requires input file ($course => $file), substring to replace ($args),
  #+ replacement string ($addargs)
    if [ "$args" != "" ] && [ "$file" != "" ] && [ "$addargs" != "" ]; then
      matched_str=$(grep -m 1 "$args" $file)
      if ! [ -z $matched_str ]; then
        echo $matched_str > $working_dir/deleted/lastline
        if [ "$operation" == "rep" ] || [ "$operation" == "-r" ]; then
          replacement=${matched_str/"$args"/"$addargs"}
        else
          replacement="$addargs"
        fi
        sed -i s/"$matched_str"/"$replacement"/g $file
        echo Changed $file: \'$matched_str\' to \'$replacement\'
        bash $0 --pull $course
      else
        echo Unable to locate \'$args\'
      fi
    else
      bash $0
    fi
    ;;

  "--find" | "-f")
  # Find - Seaches files for matching string
  # Requires string to search for ($course)
    if [ "$course" != "" ]; then
      for i in $files; do
        grep -H "$course" $i
      done
    else
      echo Missing argument\(s\)
      bash $0
    fi
    ;;

  "--sort" | "-o")
  # Sort - Prints file lines containing dates for this and next month
    #week_days="[MTWRFSU]"
    d=$(date +%-d)
    m=$(date +%-m)
    y=$(date +%Y)
    nm=$(($m % 12 + 1))
    ny=$(($y + ($m + 1) / 12))
    short_m=$(date +%b)
    short_m=${short_m,,}
    short_nm=$(cal $nm $ny |grep -o [A-Z][a-z][a-z])
    short_nm=${short_nm,,}
    todo=$(echo -e '\033[07m')
    today=$(echo -e '\033[04m\033[01m')
    clr=$(echo -e '\033[0m')

    if [ "$course" == "-c" ]; then
      cal >thisMonth
      cal $nm $ny >nextMonth
      weekday=$(date +%a)
      weekday=${weekday:0:2}
      sed -i "s/\b$d\b/$today$d$clr/g" thisMonth
      sed -i "s/\b$weekday\b/$today$weekday$clr/g" thisMonth
    fi

    for file in $files; do
      echo "> $file" >>tmp
      cat $file >>tmp
    done
    grep -H "$short_m[0-9]\{1,2\}$" $files >month
    grep -H "$short_nm[0-9]\{1,2\}$" $files >nMonth
    sed -i 's/\([^:]*\):\(.*[^0-9$]\)\([0-9]\{1,2\}\)/\3\|\1\|\2\3/g' month nMonth
    sort month -o month
    sort nMonth -o nMonth
    while read line; do
      num=$(cut -d'|' -f1 <<<$line)
      echo -n '> '
      cut -d'|' -f2 <<<$line
      task=$(cut -d'|' -f3- <<<$line)
      echo $task
      sed -i /"$task"/d tmp
      [ "$course" == "-c" ] &&\
      sed -i "s/\b$num\b/$(echo -e $todo)$num$(echo -e '\033[0m')/g" thisMonth
    done <month
    while read line; do
      num=$(cut -d'|' -f1 <<<$line)
      echo -n '> '
      cut -d'|' -f2 <<<$line
      task=$(cut -d'|' -f3- <<<$line)
      echo $task
      sed -i /"$task"/d tmp
      [ "$course" == "-c" ] &&\
      sed -i "s/\b$num\b/$(echo -e $todo)$num$(echo -e '\033[0m')/g" nextMonth
    done <nMonth
    echo
    echo -n 'Unmateched:'
    lastline=
    while read line; do
      if [[ $lastline =~ ^\>.* ]] && [[ $line =~ ^\>.* ]]; then
        lastline=$line
      else
        echo $lastline
        lastline=$line
      fi
    done <tmp
    if [[ $lastline =~ ^\>.* ]] && [[ $line =~ ^\>.* ]]; then
      lastline=$line
    else
      echo $lastline
      lastline=$line
    fi
    rm tmp month nMonth
    if [ "$course" == "-c" ]; then
      echo
      cat thisMonth
      cat nextMonth
      rm thisMonth nextMonth
    fi
    ;;

  "--conf" | "-C")
  # Conf - Prints config settings
    i=1
    j=$(echo $files |wc -w)
    while [ $i -le $j ]; do
      [ $i == 1 ] || echo
      cf=$(echo $files |cut -d' ' -f$i)
      cc=$(echo $courses |cut -d' ' -f$i)
      echo -ne "$cc -> $cf"
      (( i++ ))
    done
    echo
  ;;

  "--help" | "-h")
  # Help - Prints info on operation usage
    echo "$usage"
  ;;

  # Default - Prints minimal usage information
  *)
    echo "Usage: $(basename $0) -acCDfhpPrzRu [-o [-c/N]] [COURSE] [ARGS] [ADDARGS]"
    echo "Type cnotes -h or cnotes --help for more info"
  ;;
esac

