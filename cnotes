#!/bin/bash

# Basic scheduling program
working_dir=~/coursenotes
mkdir -p $working_dir/config
config_file="$working_dir/config/cnotes.conf"
if [ ! -f $config_file ]; then
  echo Error: Could not find cnotes.conf in $working_dir/config/
  exit 2
fi
source $working_dir/config/cnotes.conf
mkdir -p $working_dir/deleted
#---make clean option - delete and re-init
cd $working_dir

# Parameter pulling
operation="$1"
course="$2"
args="$3"
shift 
shift
message="$*"
shift
addargs="$*"

# Course selection for in/output file
touch $files
conf_courses=" $courses "
conf_search="[ |]$course[ |]"

if [ "$course" == "" ] || [ "${conf_courses/$conf_search*/}" == "$conf_courses" ]; then
  file=
else
  pos=$(($(echo $conf_courses |sed "s/[^ ]*$course.*//g" |wc -w) + 1))
  file=$(echo $files |cut -d' ' -f$pos)
fi

usage="\
Usage: cnotes [-acCDfhpPrRu] [-o [date_range/-c]] [-rl] course args addargs
  -a, --add
      append addargs to first line containing args in course
  -c, --clear
      delete first line containing args from course, temporarily
      storing it in working_dir/deleted/lastline
  -D, --del
      delete course file, temporarily storing it in
	    working_dir/deleted/        
  -f, --find
      print file lines containing args
  -h, --help
      show this menu
  -l, --list
      print all course files
  -p, --push
      append args to course
  -P, --pull
      read from course or print all with no course
  -r, --rep
  -R, --rest
      swap deleted course file with one in working_dir/deleted
      replace first line occurence of args with addargs
  -rl, --repl
      replace first line containing args with addargs
  -o, --sort
      print file lines in order containing todays date + args
	    (default 7). Use -o -c to print calendar
  -u, --undo
      append most recently cleared line to course
"
# Operation selection
case "$operation" in
  "--push" | "-p")
  #  Push - Sends input to text file
  #  Requires input ($message), file ($course => $file) 
    if [ "$file" != "" ] && [ "$message" != "" ] && [ "$course" != "" ]; then
      echo "$message" >> $file
      echo Added \'$message\' to $file
      bash $0 --pull $course
    else
      echo Invalid format
      bash $0
    fi
    ;;
  "--pull" | "-P")
  #  Pull - Prints contents of a file or of all files (with no params)
  #  Requires (optional) file to read from ($course => $file)
    if [ "$file" == "" ]; then
      bash $0 list
    else
      if [ -f $working_dir/$file ]; then
        echo \> $(basename $file)
        cat $file
      else
        echo File \'$file\' not found
      fi
    fi
    ;;
  "-D" | "--del")
  #  Delete - Removes entire contents of input file and replaces with empty one.
  #+ Stores file in deleted/ until next deletion operation.
  #  Requires input file ($course => $file)
    if [ "$file" != "" ]; then
      echo -n "Really delete $file? [Y/n]: "
      read confirm
      if [ "$confirm" == "y" ] || [ "$confirm" == "Y" ]; then
        mv $file deleted/
        touch $file
        echo Sent $file\
        to $working_dir/deleted/$file
        bash $0 list
      fi
    else
      echo Invalid format
      bash $0
    fi
    ;;
  "--clear" | "-c")
  #  Clear - Removes a single line from file, determined by the first string
  #+ containing input substring
  #  Requires input file ($course => $file) and substring ($message)
    if [ "$message" != "" ] && [ "$file" != "" ]; then
      cat $file |grep -m 1 "$message" >$working_dir/deleted/lastline &&
      sed -i /"$(grep -m 1 "$message" $file)"/d $file &&
      echo Deleted \'$(cat $working_dir/deleted/lastline)\'\
      from $file &&
      bash $0 --pull $course ||
      echo String \'$message\' not found
    else
      echo Invalid format
      bash $0
    fi
    ;;
  "--add" | "-a")
  #  Append - Appends a string onto existing line in text file
  #  Requires input file ($course => $file), substring to search for ($args),
  #+ string to append ($addargs)"
    if [ "$args" != "" ] && [ "$file" != "" ] && [ "$addargs" != "" ]; then
      if [ "$(grep -m 1 $args $file)" != "" ]; then
        sed -i s/"$(grep -m 1 $args $file)"/"$(grep -m 1 $args $file)$addargs"/g $file
        echo Appended \'"$addargs"\' to\
        $file: $args
        bash $0 --pull $course
      else
        echo Could not find \'$args\'
      fi
    else
      echo Invalid format
      bash $0
    fi
    ;;
  "--list" | "-l")
  # List - Prints contents of text files in working directory
    find . -maxdepth 1 -type f -exec echo -n "> " \; -exec basename {} \; -exec cat {} \;
    ;;
  "--undo" | "-u")
  #  Undo - restores last deleted line to a file
  #  Requires input file ($course ==> $file) 
    if [ "$file" != "" ]; then
      if [ "$(cat $working_dir/deleted/lastline 2>/dev/null)" != "" ]; then
        cat $working_dir/deleted/lastline >> $file
        echo Appended \'$(cat $working_dir/deleted/lastline)\'\
        to $file
        bash $0 --pull $course
      else
        echo Last line does not exist
      fi
    else
      bash $0
    fi
    ;;
  "--rest" | "-R")
  # Restore - Replaces text file in deleted/, swapping it with existing one in working directory
  # Requires input file ($course => $file)
    if [ "$file" != "" ]; then
      if [ -f $working_dir/deleted/$file ]; then
        mv $working_dir/deleted/$file $working_dir/tmp
        if [ -f $working_dir/$file ]; then
          mv $working_dir/$file $working_dir/deleted/
        fi
        mv $working_dir/tmp $working_dir/$file
        echo Restored $file
        bash $0 --pull $course
      else
        echo Could not restore $file: does not exist
      fi
    else
      bash $0
    fi
    ;;
  "--rep" | "-r" | "-rl" | "--repl")
  #  Replace - Replaces a single word or line in input file with another one
  #  Requires input file ($course => $file), substring to replace ($args),
  #+ replacement string ($addargs)
    if [ "$args" != "" ] && [ "$file" != "" ] && [ "$addargs" != "" ]; then
      if $(grep -qm 1 "$args" $file); then
        matched_str=$(grep -m 1 "$args" $file)
        echo $matched_str > $working_dir/deleted/lastline
        if [ "$operation" == "rep" ] || [ "$operation" == "-r" ]; then
          replacement=${matched_str/"$args"/"$addargs"}
        else
          replacement="$addargs"
        fi
        sed -i s/"$matched_str"/"$replacement"/g $file
        echo Changed $file: \'$matched_str\' \
        to \'$replacement\'
        bash $0 --pull $course
      else
        echo Unable to locate \'$args\'
      fi
    else
      bash $0
    fi
    ;;
  "--find" | "-f")
  # Find - Seaches files for matching string
  # Requires string to search for ($course)
    if [ "$course" != "" ]; then
      find $working_dir -maxdepth 1 -type f \( -exec grep -q "$course" {} \; -exec echo -n "> " \; -exec basename {} \; -exec grep "$course" {} \; \)
    else
      echo Missing argument\(s\)
      bash $0
    fi
    ;;
  "--sort" | "-o")
  # Sort - Prints file lines containing dates ranging from todays date +[0,24] in order
  # Requires (optional) number of days to iterate through and search for ($course)
    week_days="[M,T,W,R,F,S,U]"
    d=$(date +%-d)
    m=$(date +%-m)
    y=$(date +%Y)
    nm=$(($m % 12 + 1))
    ny=$(($y + ($m + 1) / 12))
    short_m=$(cal |egrep -o [A-Z][a-z]\{2\} |tr [A-Z] [a-z])
    short_nm=$(cal $nm $ny |egrep -o [A-Z][a-z]\{2\} |tr [A-Z] [a-z])
    if [ "$course" == "-c" ]; then
      length=24
      cal >thisMonth
      cal $nm $ny >nextMonth
      if [ $d -lt 10 ]; then
        replace="-- "
      else
        replace=" -- "
      fi
      sed -i s/\ $d$/"$replace"/g thisMonth
      sed -i s/\ $d\ /"$replace"/g thisMonth
			sed -i s/^$d\ /--\ /g thisMonth
    elif [ "$course" == "" ] || [ "$course" -gt "24" ] || [ "$course" -lt "0" ]; then
      length=7
    else
      length=$course
    fi
    days_this_month=$(cal |egrep -v [a-z] |wc -w)
    for i in $(find $working_dir -maxdepth 1 -type f |egrep -v tmp\|Month); do
      echo "> $(basename $i)" >>tmp
      cat $i >>$working_dir/tmp
    done
    end_day=$(( ($d - 1 + $length) % days_this_month + 1 ))
    end_month=$nm
    #echo Showing date range: $d.$m - $end_day.$end_month
    echo Showing date range: $short_m $d - $short_nm $end_day
    for (( i=$d; i<=(( $d + $length )); i++ )); do
      [ "$(egrep $week_days$short_m[0-9]\{1,2\}$\|$week_days$short_nm[0-9]\{1,2\}$ tmp)" != "" ] || break
      if [ $i -gt $days_this_month ]; then
        day=$(( $i - $days_this_month ))
        calMonth=nextMonth
        currMonth=$short_nm
      else
        day=$i
        calMonth=thisMonth
        currMonth=$short_m
      fi
      for file in $(find $working_dir -maxdepth 1 -type f |egrep -v tmp\|Month); do
        if [ "$(egrep $week_days$currMonth$day$ $file)" != "" ]; then
          echo  "> $(basename $file)"
          egrep $week_days$currMonth$day$ $file |tee del
          while read line; do
            sed -i /"$line"/d $working_dir/tmp
          done <del
          rm del
          if [ "$course" == "-c" ]; then
            if [ "$day" -lt "10" ]; then
              replace="xx "
            else
              replace=" xx "
            fi
            cat $calMonth |sed s/\ $day$/"$replace"/g |sed s/\ $day\ /"$replace"/g >calTmp
						sed -i s/^$day\ /xx\ /g calTmp
						mv calTmp $calMonth
          fi
        fi
      done
    done
    lastline=
    while read line
    do
      if [ "$(echo $line |grep \>)" != "" ] && [ "$(echo $lastline |grep \>)" != "" ]; then
        sed -i "/$lastline/d" tmp 
      fi
      ilastline=$line
    done < tmp 
    if [ "$(echo $lastline |grep \>)" != "" ]; then
      sed -i "/$lastline/d" tmp 
    fi
    echo
    if [ "$(cat tmp)" != "" ]; then
      echo Unmatched:
      cat tmp
      echo
    fi
    rm tmp
    if [ "$course" == "-c" ]; then
      cat thisMonth |sed '$ d'
      cat nextMonth
      rm thisMonth nextMonth
    fi
    ;;
  "--conf" | "-C")
  # Conf - Prints config settings
    i=1
    j=$(echo $files |wc -w)
    while [ $i -le $j ]; do
      [ $i == 1 ] || echo -ne ", "
      cf=$(echo $files |cut -d' ' -f$i)
      cc=$(echo $courses |cut -d' ' -f$i)
      echo -ne "$cc->$cf"

      (( i++ ))
    done
  ;;
  "--help" | "-h")
  # Help - Prints info on operation usage
    echo "$usage"
  ;;
  # Default - Prints minimal usage information
  *)
    echo "Usage: cnotes [-acCDfhpPrRu] [-o [date_range/-c]] [-rl] course args addargs"
    echo "Type cnotes -h or cnotes --help for more info"
  ;;
esac

